import osimport jsonimport numpy as npimport faissfrom datetime import datetimefrom sentence_transformers import SentenceTransformerclass SemanticMemory:    def __init__(self, memory_dir="penny_mem", embed_model="all-MiniLM-L6-v2"):        self.memory_dir = memory_dir        self.index_file = os.path.join(memory_dir, "faiss.index")        self.meta_file = os.path.join(memory_dir, "metadata.json")        self.model = SentenceTransformer(embed_model)        self.metadata = []        self.index = None        self.dim = 384  # Embedding size for MiniLM        os.makedirs(memory_dir, exist_ok=True)        self._load()    def _load(self):        # Load FAISS index if exists        if os.path.exists(self.index_file) and os.path.exists(self.meta_file):            self.index = faiss.read_index(self.index_file)            with open(self.meta_file, "r") as f:                self.metadata = json.load(f)        else:            self.index = faiss.IndexFlatL2(self.dim)            self.metadata = []    def _save(self):        faiss.write_index(self.index, self.index_file)        with open(self.meta_file, "w") as f:            json.dump(self.metadata, f, indent=2)    def add_memory(self, role, content):        """Adds a memory vector with metadata."""        embedding = self.model.encode([content]).astype("float32")        self.index.add(embedding)        self.metadata.append({            "timestamp": datetime.now().isoformat(),            "role": role,            "content": content        })        self._save()    def recall(self, query, k=5):        """Returns top-k semantically similar memories."""        if len(self.metadata) == 0:            return []        embedding = self.model.encode([query]).astype("float32")        distances, indices = self.index.search(embedding, k)        results = []        for dist, idx in zip(distances[0], indices[0]):            if idx == -1:  # FAISS returns -1 if no results                continue            memory = self.metadata[idx]            results.append({                "timestamp": memory["timestamp"],                "role": memory["role"],                "content": memory["content"],                "similarity": float(1 - dist / 2)  # Convert L2 distance to loose similarity            })        return results