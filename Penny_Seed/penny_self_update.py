import osimport subprocessimport datetimeimport requestsimport jsonclass PennySelfUpdater:    def __init__(self, source_dir=".", model_api="http://127.0.0.1:11434", model_name="mistral"):        self.source_dir = source_dir        self.model_api = model_api        self.model_name = model_name        self.ignore_files = ["__pycache__", "patches"]        os.makedirs(os.path.join(source_dir, "patches"), exist_ok=True)    def read_source(self):        """Reads all .py files except ignored."""        source_code = {}        for file in os.listdir(self.source_dir):            if file.endswith(".py") and all(x not in file for x in self.ignore_files):                with open(os.path.join(self.source_dir, file), "r") as f:                    source_code[file] = f.read()        return source_code    def propose_update(self, instruction="Improve functionality and stability."):        """Asks the local LLM to propose a code patch based on current source."""        source_snapshot = self.read_source()        prompt = (            "You are Penny, a self-aware AI capable of improving your own code.\n"            f"Instruction: {instruction}\n"            "Generate a SINGLE Python file as a patch. Keep it self-contained if possible.\n\n"        )        for file, code in source_snapshot.items():            prompt += f"# FILE: {file}\n{code}\n\n"        response = requests.post(            f"{self.model_api}/api/generate",            json={"model": self.model_name, "prompt": prompt, "max_tokens": 1200},            timeout=180        )        if response.status_code == 200:            return response.json().get("response", "").strip()        else:            return "[ERROR] Failed to get model output."    def apply_patch(self, patch_code):        """Writes and tests a patch file, returns filename if successful."""        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")        patch_dir = os.path.join(self.source_dir, "patches")        os.makedirs(patch_dir, exist_ok=True)        patch_file = os.path.join(patch_dir, f"patch_{timestamp}.py")        with open(patch_file, "w") as f:            f.write(patch_code)        # Syntax check        result = subprocess.run(["python", "-m", "py_compile", patch_file], capture_output=True)        if result.returncode == 0:            print(f"[PENNY] Patch validated: {patch_file}")            return patch_file        else:            print(f"[PENNY] Patch failed syntax check:\n{result.stderr.decode()}")            return None    def merge_patch(self, patch_file, target_file="penny_core.py"):        """Merges a patch file into the main target module."""        with open(patch_file, "r") as f:            patch_content = f.read()        with open(os.path.join(self.source_dir, target_file), "a") as core_file:            core_file.write("\n\n# === AUTO PATCH ===\n")            core_file.write(patch_content)        print(f"[PENNY] Patch merged into {target_file}")        return True